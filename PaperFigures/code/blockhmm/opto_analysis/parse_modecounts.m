% For parsing the modecounts file generated by
% process_animal_info.m

load modecounts_033122.mat

NSTATES = numel(modecounts(1).count_opto{1,1,1}); 

%% count the number of opto/no opto blocks for each condition per animal
nblocks_opto_all = cell(1, numel(modecounts));
nblocks_no_opto_all = cell(1, numel(modecounts));


for animalID = 1:numel(modecounts)
    count_opto = modecounts(animalID).count_opto;
    count_no_opto = modecounts(animalID).count_no_opto;
    
    nblocks_opto_all{animalID} = cellfun(@(x) sum(x), count_opto);
    nblocks_no_opto_all{animalID} = cellfun(@(x) sum(x), count_no_opto);
    
end


%% plot of opto effect given specific conditions
period_criterion = 'outcome'; %oucome/choice/none
power_criterion = 'high'; %low/high/none
msize = 20;

for stateID = 1:NSTATES
    [idxperiod, idxpower] = find_idx_set(modecounts, power_criterion, period_criterion);
    figure;
    delta = 0.1; %how far apart opto/non-opto columns are
    for animalID = 1:4 %numel(modecounts)
        counts_opto = block_counter(modecounts(animalID).count_opto, idxperiod, idxpower);
        [nareas, nstates] = size(counts_opto);

        opto_states_frac = counts_opto ./ sum(counts_opto, 2);
        opto_states_frac_error = sqrt(opto_states_frac .* (1 - opto_states_frac) ./ sum(counts_opto, 2));

        counts_no_opto = block_counter(modecounts(animalID).count_no_opto, idxperiod, idxpower);
        no_opto_states_frac = counts_no_opto ./ sum(counts_no_opto, 2);
        no_opto_states_frac_error = sqrt(no_opto_states_frac .* (1 - no_opto_states_frac) ./ sum(counts_no_opto, 2));


        % plot opto fractions
        switch animalID
            case 1
                l1 = errorbar((1:nareas) + delta, opto_states_frac(:,stateID), opto_states_frac_error(:,stateID), 'bo',...
                    'MarkerSize', msize);
                hold on
                errorbar((1:nareas) - delta, no_opto_states_frac(:,stateID), no_opto_states_frac_error(:,stateID), 'ko',...
                    'MarkerSize', msize);
       
                
            case 2
                l2 = errorbar((1:nareas) + delta, opto_states_frac(:,stateID), opto_states_frac_error(:,stateID), 'bx',...
                    'MarkerSize', msize);
                hold on
                errorbar((1:nareas) - delta, no_opto_states_frac(:,stateID), no_opto_states_frac_error(:,stateID), 'kx',...
                    'MarkerSize', msize);

             
                
            case 3
                l3 = errorbar((1:nareas) + delta, opto_states_frac(:,stateID), opto_states_frac_error(:,stateID), 'b*',...
                    'MarkerSize', msize);
                hold on
                errorbar((1:nareas) - delta, no_opto_states_frac(:,stateID), no_opto_states_frac_error(:,stateID), 'k*',...
                    'MarkerSize', msize);
        
                
                
            case 4
                l4 = errorbar((1:nareas) + delta, opto_states_frac(:,stateID), opto_states_frac_error(:,stateID), 'ro',...
                    'MarkerSize', msize);
                hold on
                errorbar((1:nareas) - delta, no_opto_states_frac(:,stateID), no_opto_states_frac_error(:,stateID), 'ko',...
                    'MarkerSize', msize);

           
                
        end     
       % connect pairs of opto/no-opto
        for areaID = 1:nareas
            plot([areaID - delta, areaID + delta], [no_opto_states_frac(areaID, stateID), ...
                opto_states_frac(areaID, stateID)], 'k');   
        end
                


    end

    xticks(1:4)
    xticklabels(modecounts(1).area_criteria);
    
    legend([l1, l2, l3, l4], {'f26', 'f27', 'f29', 'f32'}, 'FontSize', 15);
end



%% Plot the transition functions (opto vs no-opto)
period_criterion = 'outcome'; %oucome/choice/none
power_criterion = 'low'; %low/high/none
[idxperiod, idxpower] = find_idx_set(modecounts, power_criterion, period_criterion);

for regionID = 1:4
    for animalID = 1:4
        transfunc_opto = modecounts(animalID).transfunc_opto{idxpower, ...
            regionID, idxperiod};
        transfunc_no_opto = modecounts(animalID).transfunc_no_opto{idxpower,...
            regionID, idxperiod};
        
        count_opto = modecounts(animalID).count_opto{idxpower, regionID, ...
            idxperiod};
        N_opto = sum(count_opto(:));    
        
        count_no_opto = modecounts(animalID).count_no_opto{idxpower, regionID, ...
            idxperiod};
        N_no_opto = sum(count_no_opto(:));
        T = numel(transfunc_opto);
        
        error_opto = sqrt(transfunc_opto .* (1-transfunc_opto) / N_opto);
        error_no_opto = sqrt(transfunc_no_opto .* (1-transfunc_no_opto) / N_no_opto);
               
        figure;
        errorbar(1:T, 1-transfunc_opto, error_opto, 'b', 'LineWidth', 2)
        hold on
        errorbar(1:T, 1-transfunc_no_opto, error_no_opto, 'k', 'LineWidth', 2)
        title(sprintf('animal %s, area %s', modecounts(animalID).animal,...
            modecounts(animalID).area_criteria{regionID}));
        
    end
end







function [idxperiod, idxpower] = find_idx_set(modecounts, power_criterion, ...
    period_criterion)

if strcmp(power_criterion, 'none')
    idxpower = [1,2];
else
    idxpower = find(contains(modecounts(1).power_criteria, power_criterion));
end

if strcmp(period_criterion, 'none')
    idxperiod = [1,2];
else
    idxperiod = find(contains(modecounts(1).period_criteria, period_criterion));
end

end


function counts = block_counter(arr, idxperiod, idxpower)
% arr: a cell with n power x n area x n periods
% idxperiod: array, subset of periods of interest
% idxpower: array, subset of powers of interest
% counts: nareas x nstates array, with the counts of n blocks in each state
% per area
[npower, nareas, nperiods] = size(arr);
assert(max(idxperiod) <= nperiods);
assert(max(idxpower) <= npower);

nstates = numel(arr{1,1,1});

counts = zeros(nareas, nstates);

for i = 1:numel(idxpower)
    poweridx = idxpower(i);
    for j = 1:nareas
        for k = 1:numel(idxperiod)
            periodidx = idxperiod(k);
            count_condition = arr{poweridx, j, periodidx};
            
            counts(j, :) = counts(j, :) + count_condition;
            
        end
    end
end

end















